React Context
컴포넌트간의 데이터를 전달하는 또 다른 방법
기존의 props는 drilling이라는 문제가 있었다. 바로 depth가 깊어지면 깊이만큼 props를 계속해줘야 하기 때문. 그래서 이러한 문제를 해결하기 위해 사용하는것이 context이다. 여러개 만들어서 기능을 나눠줄수도 있다. 


Multi Page Application(MPA)
애초에 서버가 여러개의 페이지를 가지고 있음 많은 서비스가 사용하는 전통적인 방식

Server Side Rendering
브라우저 요청 -> 서버는 미리 만들어놓은 HTML 파일(MPA 방식)을 브라우저에 보내줌 -> 이걸 그대로 렌더링


하지만, 리액트는 위 방식을 사용하지 않음 왜냐하면, 공통적인 요소가 있더라도 기존 렌더링해놨던 페이지를 전부 지우고 새로운 페이지를 받아와서 처음부터 다시 렌더링하여 쾌적한 페이지 이동 제공이 어렵기 때문. 이 때문에 계속 새로고침되면서 깜빡이며 이는 비효율적임. 그렇기에 다수의 사용자가 요청을 보낼시 서버 부하가 심해져 성능저하가 일어나거나 심할경우 터지기 까지 할 수 있음.


SPA(Single Page Application) 이것이 리액트의 방식 되시겠다.
페이지의 이동이 매끄럽고 효율적이며 다수의 사용자가 접속해도 크게 상관없다는 장점이 있다.
vite는 서버에 있는 컴포넌트들을 번들링(묶어서) 브라우저에 전달한다. 이때 번들파일은 리액트 컴포넌트들이 하나의 파일로 묶여있는 자바스크립트 파일이기 때문에 이 파일은 리액트 앱이라고 부를 수 있다.(브라우저에서 실행되는 리액트앱) 그러면 이중에 main.jsx가 가장 먼저 호출이 되고 렌더 메서드가 호출이 되면서 앱 컴포넌트를 화면에 렌더링하게됨.
이건 클라이언트 측에서 렌더링 시키는 것이며, 이는 클라이언트 사이드 렌더링이라 한다.
또한, 서버에 요청을 보내서 페이지를 받아오는 것이아니라 처음 리액트앱으로 받은 파일들을 이용해서 브라우저가 스스로 페이지를 이동시킴. 


```
npm i react-router-dom
```

```
<BrowserRouter/>  // 브라우저의 현재 주소를 저장하고 감지하는 역할
```
리렌더링 될 때마다 생성하거나 실행할거아니면 컴포넌트 바깥으로 빼놓는것이 좋다. 

useContext 객체를 생성해서 콘솔 찍어보면 Provider라는게 있는데 context객체.Provider는 사실 컴포넌트다. 이걸로 props받은 애들을 감싸주면 provider의 자식들은 모두 context객체의 데이터를 공급받을 수 있게된다. 그래서 공급을 하고자하는 애들을 명시해줘야한다. value안에서 예를 들어, onCreate = {onCreate}인 부분에 전달해주고 싶으면 <Context.Provider valu={{onCreate}}>로 전달

그리고 해당 props를 받는 컴포넌트로 가서 

```
const TodoContext = createContext()
---------------------------------

import {TodoContext} from "../App"

const TodoItem = ({id, isDone, content, data}) => {
    const { onUpdate, onDelete } = useContext(TodoContext)
} // 구조분해할당을 해줄때 useContext 인자로 TodoContext 넣는부분 꼭 기억
```

허나, 이런식으로하면 효율성을 위해 사용했던 최적화들이 적용안됨
그 이유는 앱컴포넌트의 스테이트가 변경되면 context객체들이 모두 재생성되면서 연결되어 있는 컴포넌트들에서 리렌더링이 이루어지기 때문이다. 
이러한 문제를 해결하기 위해서는 context를 두가지로 나누어야 하는데, 변경될 수 있는 값은 TodoStateContext로 변경되지 않는 값은 TodoDispatchContext로 분리해서 공급하면된다.


